package days12;

// 일반(상속관계가 없는) 객체의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 생성
// 2. 생성자 메서드를 호출

// 상속관계 있는 객체(자식객체)의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 생성 - 부모/자식 클래스의 모든 멤버변수를 한번에 생성
// 2. 자식클래스 객체가 생성되는 것이므로 자식 클래스의 생성자가 먼저 호출
// 3. 자식클래스 생성자의 첫번째 실행코드가 부모클래스의 생성자를 호출
//     	- 자식클래스의 생성자 명령 중 첫줄이 부모 클래스의 생성자 호출이라는 것
//		- 자식클래스 생성자 명령의 첫줄은 super();라는 명령이며 따로 기술하지 않아도 존재하는 명령
//		- 디폴트 생성자처럼 숨어있는 명령이라고 할 수 있습니다.
// 4. 부모클래스 생성자를 모두 실행한 후 자식클래스 생성자의 남은 명령을 실행
//		- 구조가 이렇게 짜여진 이유를 들자면, 부모클래스의 private멤버를 자식 클래스의 생성자에서 초기화 할수 없으므로
//		  부모클래스 생성자를 통해 접근하고 초기화하기 위함

class SuperB{
	int superNum;
	public SuperB(){
		System.out.println("부모클래스의 생성자 실행");
	}
}

class SubB extends SuperB{
	int subNum;
	// 생성자를 별도로 꺼내서 정의하지 않았다면....
	//SubB(){
	//	super();
	//} 이와같은 생성자와 명령이 숨어있는 것과 같습니다.
	
	// 생성자를 꺼내서 별도로 정의한 경우 super() 명령의 다른 명령도 쓸수 있습니다.
	public SubB() {
		super();
		// 자식 클래스에서 부모클래스 생성자 호출은 super();라고 명령하며, 반드시 첫번째 실행코드로 씁니다.
		System.out.println("자식클래스의 생성자 실행");
		
		
		// super() 명령은 꺼내도 되고 안꺼내도 상관없음, 반드시 꺼내서 써야하는 경우가 있음
		// 		- 부모생성자가 매개변수가 존재하는 생성자로 대체 되어있는 경우
		//		- 자식생성자의 첫줄명령 (super();)을 꺼내놓지 않으면 자동으로 매개변수가 없는 디폴트 생성자를 호출
		// 		- 이때 부모생성자가 매개변수가 있는 생성자로 대체 된다면, 없는 부모생성자를 호출한 것이므로 에러입니다.
		// 이 에러를 해결할 수 있는 방법
		
		// 1. 부모 클래스의 매개변수 형태대로 호출 : super(); 에 전달인수를 넣어줍니다. super(10);
		// 2. 부모클래스의 생성자를 오버로딩해서 자식클래스 생성자에서 호출하는 형태로 부모클래스 생성자를 추가합니다.
				
		// super() 호출의 두가지 방법
		// ###부모클래스의 생성자형태로 호출하거나, 자식클래스 생성자에서 호출하는 형태로 부모클래스의 생성자가 있거나
	}
}

public class Extends04 {

	public static void main(String[] args) {
		SubB b = new SubB();
	}

}
